// IMPORTANT: This file is automatically generated
// If you would like to update it, try yarn generate
import { remoteCall } from "../kolmafia/remote";
import { makePlaceholder } from "../kolmafia/placeholder";

export const enumeratedTypePlural = {
  Bounty: "bounties",
  Class: "classes",
  Coinmaster: "coinmasters",
  Effect: "effects",
  Element: "elements",
  Familiar: "familiars",
  Item: "items",
  Location: "locations",
  Modifier: "modifiers",
  Monster: "monsters",
  Path: "paths",
  Phylum: "phyla",
  Servant: "servants",
  Skill: "skills",
  Slot: "slot",
  Stat: "stat",
  Thrall: "thralls",
  Vykea: "vykea",
} as const;

export type EnumeratedTypeName = keyof typeof enumeratedTypePlural;

export function isEnumeratedTypeName(name: string): name is EnumeratedTypeName {
  return name in enumeratedTypePlural;
}

export const numberTypeNames = [
  "Class",
  "Effect",
  "Familiar",
  "Item",
  "Location",
  "Monster",
  "Path",
  "Servant",
  "Skill",
  "Thrall",
] as const;

export type NumberTypeName = (typeof numberTypeNames)[number];

export function isNumberTypeName(name: string): name is NumberTypeName {
  return (numberTypeNames as readonly string[]).includes(name);
}

export type HasNumber<T> = T extends NumberTypeName ? true : false;

export type ValidIdentifier<T extends EnumeratedTypeName> =
  HasNumber<T> extends true ? number | string : string;

export type TypeName<T> = T extends MafiaClass<infer U> ? U : never;

abstract class MafiaClass<T extends EnumeratedTypeName> {
  static readonly staticType: EnumeratedTypeName;
  readonly objectType: T;
  readonly identifierString: string;
  readonly identifierNumber: HasNumber<T> extends true ? number : undefined;

  constructor(values: {
    [K in keyof MafiaClass<T>]: MafiaClass<T>[K];
  }) {
    this.objectType = values.objectType;
    this.identifierString = values.identifierString;
    this.identifierNumber = values.identifierNumber;
  }

  static replaceValues<U extends object>(
    this: {
      new (values: { [K in keyof U]: U[K] }): U;
      readonly staticType: TypeName<U>;
    },
    obj: U,
    values: {
      [K in keyof U]: U[K];
    },
  ) {
    Object.assign(obj, values);
  }

  static get<U>(
    this: {
      new (values: { [K in keyof U]: U[K] }): U;
      readonly staticType: TypeName<U>;
      readonly none: U;
    },
    idOrArray: ValidIdentifier<TypeName<U>>,
  ): U;
  static get<U>(
    this: {
      new (values: { [K in keyof U]: U[K] }): U;
      readonly staticType: TypeName<U>;
      readonly none: U;
    },
    idOrArray: ValidIdentifier<TypeName<U>>[],
  ): U[];
  static get<U>(
    this: {
      new (values: { [K in keyof U]: U[K] }): U;
      readonly staticType: TypeName<U>;
      readonly none: U;
    },
    idOrArray: ValidIdentifier<TypeName<U>> | ValidIdentifier<TypeName<U>>[],
  ): U | U[] {
    const ids = Array.isArray(idOrArray) ? idOrArray : [idOrArray];

    const results = ids.map((id) => {
      if (id === "" || id === undefined || id === null || (typeof id === "string" && id.toLowerCase() === "none")) {
        return this.none;
      }

      const placeholder = makePlaceholder<TypeName<U>>(this.staticType, id);
      const default_ =
        "identifierNumber" in placeholder
          ? {
              ...this.none,
              ...placeholder,
              identifierString: `${placeholder.identifierNumber}`,
            }
          : {
              ...this.none,
              ...placeholder,
              identifierNumber: -1,
            };
      return remoteCall("identity", [placeholder], default_) as unknown as U;
    });

    return Array.isArray(idOrArray) ? results : results[0];
  }

  static all<U extends EnumeratedTypeName, V extends MafiaClass<U>>(): V[] {
    return [];
  }
}
